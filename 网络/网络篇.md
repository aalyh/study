1. 网络有哪几层？分别有哪些协议
 五层模型从上到下为：应用层 -> 传输层 -> 网络层 -> 数据链路层 -> 物理层
 - 应用层是最上层模型，是用户直接接触到的，专注于为用户提供应用功能，有HTTP、FTP、Telnet、DNS、SMTP等协议，应用层将数据包传递给传输层。
 - 传输层为应用层提供网络支持，有两个传输协议：TCP和UDP。TCP协议为可靠传输，需要建立连接。UDP不可靠传输，不需要建立连接。
 - 网络层最常使用IP协议，IP协议将传输层的报文加上IP包头组装成IP报文进行传输，使用IP地址为设备编号（寻址和路由）
    - 网络号：负责标识该IP地址是属于哪个子网的 （例如：10.100.122.0/24，子网掩码为：11111111 11111111 11111111 00000000 将10.100.122.0与子网掩码进行按位与运算，得到网络号）
    - 主机号：负责标识同一子网下的不同主机（同上，将子网掩码取反后与IP地址进行按位与运算，得到主机号）
    - 寻址的过程中先匹配到相同的网络号，再找对应的主机。
 - 数据链路层的数据单元是帧，在IP头部的前面添加MAC头部并封装成帧   封装成帧 差错控制 可靠传输 

2. 你提到用keep-alive实现，keep-alive属于网络哪一层的内容，具体有什么作用？
TCP的keepAlive 和 HTTP的keep-alive
- HTTP 的 Keep-Alive，是由应用层（用户态） 实现的，称为 HTTP 长连接
 - HTTP短连接：每次请求都会经历 建立TCP（三次握手建立连接） -> 请求资源 -> 响应资源 -> 释放连接（四次挥手释放连接），一次连接只能请求一次资源。
 - HTTP长连接（Keep-Alive）:可以使用同一个TCP连接来发送和接收多个HTTP请求/应答，避免了连接建立和释放的开销。特点是只要任意一端没有明确提出断开连接，则保持TCP连接状态

HTTP的Keep-Alive使用：
 - 在 HTTP 1.0 中默认是关闭的，如果浏览器要开启 Keep-Alive，它必须在请求的包头中添加：`Connection: Keep-Alive`，同时服务器回应的响应头中也有`Connection: Keep-Alive`
 - 从 HTTP 1.1 开始， 就默认是开启了 Keep-Alive，如果要关闭 Keep-Alive，需要在 HTTP 请求的包头里添加：`Connection:close`

HTTP长连接既可以减少TCP连接资源的开销，也给HTTP流水线技术提供了可实现的基础，即客户端可以先一次性发送多个请求，而在发送过程中不需先等待服务器的响应。为了避免队头阻塞导致TCP连接一直占用而浪费资源，提供keepalive_timeout参数来指定长连接的超时时间

- TCP 的 Keepalive，是由 TCP 层（内核态） 实现的，称为 TCP 保活机制
 - TCP 保活机制可以在双方没有数据交互的情况，通过探测报文，来确定对方的 TCP 连接是否存活，这个工作是在内核完成的

**HTTP基本概念**
3. HTTP是什么
 HTTP：超文本传输协议 双向协议  HTTP是一个在计算机世界里专门在两点之间传输文字、图片、音频、视频等超文本数据的约定和规范

4. http常见的状态码
 - 1xx：提示信息，目前是协议处理的中间状态，还需要后续操作
 - 2xx：成功，报文已经收到并被正确处理 常见：200（响应头有body数据） 204（响应头无body数据） 206（用于分块下载和断点续传，表示返回的body数据只是一部分）
 - 3xx：重定向，资源位置发生变动，需要客户端重新发送请求 常见：301（永久重定向，请求的资源已经不存在，需要用新的url访问） 302（临时重定向） 304（缓存重定向，可以继续使用缓存资源）
 - 4xx：客户端错误，请求报文有误，服务器无法处理 常见：400（客户端请求的报文有错误） 403（服务器禁止访问资源） 404（表示请求的资源在服务器上不存在或未找到）
 - 5xx：服务器错误，服务器在处理请求时内部发生了错误 常见：500（笼统通用的错误码，服务器发生错误） 501（客户端请求的功能还不支持） 502（客户端请求的功能还不支持） 503（服务器当前很忙，暂时无法响应客户端）

6. HTTP的常见字段
 - Host字段：客户端发送请求，用来指定服务器的域名
 - Content-Length字段：服务器在返回数据是表示数据长度
 - Connection字段：客户端要求服务器使用HTTP长连接机制
 - Content-Type字段：用于服务器回应是表示本次数据的格式
 - Content-Encoding字段：说明数据的压缩方法

7. 304状态码对应的协商缓存和强缓存
 - 强缓存：只要浏览器判断缓存没有过期，则直接使用浏览器的本地缓存，决定是否使用缓存的主动性在浏览器
  `Cache-Control`：相对时间  优先级 >   `Expires`：绝对时间
 - 协商缓存：请求响应304，服务器告知客户端可以使用缓存 协商缓存就是与服务端协商之后，通过协商结果来判断是否使用本地缓存。
 通过请求头部`If-Modified-Since`和响应头部`Last-Modified`
  响应头部中的 `Last-Modified`：标示这个响应资源的最后修改时间；
  请求头部中的`If-Modified-Since`：当资源过期了，发现响应头中有`Last-Modified`声明，则再次发起请求时携带`Last-Modified`的时间，服务器收到请求后与被请求资源的最后修改时间进行对比，如果最后修改时间较新，则返回最新资源，如果最后修改时间较旧，则说明资源无修改，返回304

协商缓存需要配合强缓存中的`Cache-Control`字段使用，只有未命中强缓存的时候才发起带有协商缓存字段的请求

8. GET和POST的区别
 - GET 从服务器获取指定的资源 参数一般写在URL中，且参数只允许ASCII字符，浏览器对URL的长度有限制 安全（不会破坏服务器上的资源）且幂等 （每次返回的结果是相同的）可以对GET请求的数据做缓存
 - POST 根据请求符合对指定的资源做出处理 参数携带在body中 数据可以是任意格式 浏览器不会对body大小做限制 不安全不幂等 浏览器一般不会缓存POST请求

**HTTP特性**
9. HTTP/1.1 的优点？
 - 简单：报文格式是`header + body`, 头部信息是`key-value`的形式，易于理解
 - 灵活和易于扩展：HTTP协议里的各类请求方式、URL/URI、状态码、头字段等每个组成要求都没有被固定死，都允许开发人员自定义和扩充。
   HTTPS是在HTTP与TCP层之间增加了SSL/TLS安全传输层；HTTP/1.1和HTTP/2.0传输协议使用的是TCP协议，HTTP/3.0传输协议改用UDP协议
- 应用广泛和跨平台

10. HTTP/1.1 的缺点？

11. http2.0是怎么实现多路复用的？
3. http和https的区别

6. http2.0做了哪些升级

9.  提到了网络方面进行优化，为什么http2.0可以做到？
6. 简历中提到了webSocket，能说一下webSocket是怎样建连的吗？
10. TCP三次握手

6. 浏览器输入url之后的过程  DNS请求 -> 发起TCP请求 -> 发起HTTP请求 -> 处理请求 -> 浏览器渲染 -> TCP连接断开
 - HTTP: 解析URL -> 生成HTTP请求信息 -> 发出DNS请求
 - DNS： 查询服务器域名对应的IP地址
 - 协议栈： 获取到IP后将HTTP的传输工作交给操作系统中的协议栈
 - 可靠传输TCP：三次握手建立连接 ——> TCP分割数据 -> TCP报文生成 -> 
 - 远程定位IP：IP报文生成
 - 两点传输MAC：在IP头部加上MAC头部
 - 出口 - 网卡：将数字信号转换为电信号
 - 交换机：根据MAC地址表查找MAC地址，然后将信号发送到相应的端口
 - 路由器：转发网络包
 - 服务器和客户端：发送端从上到下依次封包，接收端从下到上依次拆包

4. TCP和UDP，应用场景
5. DNS（这个开始听错了，说没听过，然后后知后觉是这个）


3. 浏览器缓存，不知道具体问的啥，直接把强缓存，协商缓存，localStorage，sessionStorage这些全说了
4. 跨域
2. webSocket 连接过程是怎么做的安全措施


## 应用层
1. uri和url的区别：uri是统一资源标识符  url是统一资源定位符，统指绝对路径  url是uri的子集
2. dns的工作原理？主要解析过程？

   客户端查询域名的ip地址的过程：查询本地hosts文件是否有网址映射关系 -> 查询本地dns解析器缓存 -> 查询本地dns服务器 -> 本地dns服务器访问根服务器，从根服务器中查找对应的顶级域名服务器并继续向下查找域名服务器的ip。

   dns默认使用udp协议
3. 用户输入网址到显示对应页面的全过程
   用户输入网址 -> DNS解析 -> TCP连接 -> 发起HTTP请求 -> 处理请求 -> 浏览器渲染 -> TCP连接断开
4. http头部包含哪些信息
   - 通用首部字段：请求和响应都可以使用的首部，与报文相关的最基本的信息。
   - 请求首部字段：仅在请求中使用的首部。
   - 响应首部字段：仅在响应中使用的首部。
   - 实体首部字段：用于应对实体部分的首部，一般是对实体内容进行说明
5. http方法了解哪些
   - get：请求指定的页面信息并返回内容，通常只用于读取数据
   - head：类似于get请求，但返回的响应中没有具体内容，只用于获取报头
   - post：向指定资源提交数据进行处理请求，数据被包含在请求体中。
   - put：替换指定资源，没有就新增
   - delete：请求服务器删除url标识的资源数据
   - options：向服务器发送该方法，会返回对指定资源所支持的http请求方法
6. http状态码了解哪些
   - 1xx：提示信息，目前是协议处理的中间状态，还需要后续操作 正在处理
   - 2xx：成功，报文已经收到并被正确处理 常见：200（响应头有body数据） 204（响应头无body数据） 206（用于分块下载和断点续传，表示返回的body数据只是一部分）
   - 3xx：重定向，资源位置发生变动，需要客户端重新发送请求 常见：301（永久重定向，请求的资源已经不存在，需要用新的url访问） 302（临时重定向） 304（缓存重定向，可以继续使用缓存资源）
   - 4xx：客户端错误，请求报文有误，服务器无法处理 常见：400（客户端请求的报文有错误） 403（服务器禁止访问资源） 404（表示请求的资源在服务器上不存在或未找到）
   - 5xx：服务器错误，服务器在处理请求时内部发生了错误 常见：500（笼统通用的错误码，服务器发生错误） 501（客户端请求的功能还不支持） 502（客户端请求的功能还不支持） 503（服务器当前很忙，暂时无法响应客户端）
7. get和post的区别
   - get携带的参数放在url上，post携带的参数放在body内
   - get请求参数以url形式完整保留在浏览器记录中，存在安全问题，post请求参数不会被浏览器记录
   - post可以进行复杂的加密，get不行
   - get只支持ASCII字符格式的参数，post无限制
   - get提交的数据大小有限制，post无限制
   - get方法具有幂等性，post不具有
   - post方法有时会发送两个tcp数据包，即先发送header再发送data
8. http和https的区别
   http: 
      - 使用明文通信，内容可能会被窃听
      - 不验证通信方的身份，通信方的身份有可能遭遇伪装
      - 无法证明报文的完整性，报文可能被篡改
   https:
      - https发送时，request通过ssl/tls进行处理，然后再通过tcp进行发送；数据接收时也统一需要处理。
9. https的加密方式
   - 数据加密
   - 数字证书认证
   - 通过ssl/tls报文摘要功能检验报文完整性

   数据加密的方式：对称加密和非对称加密（对称加密指加密和解密使用同一密钥，非对称加密指加密和解密使用不同的密钥）
   https的加密方式：
         1. 发送方获取接收方非对称加密的公开密钥
         2. 通过非对称加密的公开密钥对对称加密的密钥进行加密
         3. 将加密后的密钥发送给接收方
         4. 接收方使用非对称加密的私钥对对称加密的密钥进行解密
         5. 双方都具有对称加密的密钥，相互之间都可以通信
10. http是不保存状态的协议，如何保存用户状态？
   - session的形式：
      1. 客户端第一次发送信息到服务器时，服务器为该客户端创建一个session对象，该session包含客户端身份信息，同时为该session生成一个sessionId
      2. 服务器端将sessionId分配给客户端，客户端发送请求时带有此sessionId，服务端就可以区分客户端。
   - coockie的形式
      1. 客户端第一次发送信息到服务器时，服务器根据该客户端信息编码加密生成一个cookie
      2. 服务器端将cookie发送到客户端，客户端发送请求时带有此cookie，服务器就可以区分客户端。
11. http不同版本的区别
   - http 0.9
   - http 1.0 第一个正式版本
   - http 1.1 默认长连接，支持流水线，支持同时打开多个TCP连接 支持虚拟主机 新增状态码100 新增缓存处理指令max-age 不会压缩请求和响应首部 不支持有效的资源优先级
   - http 2.0 采用二进制传送 支持多路复用 头部压缩 支持服务器推送
   - http 3.0 使用udp作为传输层协议 quic协议保证安全性 建立连接快 

## 传输层
1. 为什么要进行三次握手？两次握手可以吗？
   第一次握手：确认客户端可以正常发送数据
   第二次握手：确认客户端可以正常发送数据 确认服务端可以正常接收数据
   第三次握手：确认客户端可以正常发送数据，确认服务端可以正常接收数据，确认服务端可以正常发送数据，服务可以正常接收数据。

   三次握手的原因：
      - 阻止重复历史连接的初始化
      - 同步双方的初始序列号
      - 避免资源浪费
2. 为什么要四次挥手？
   确认双方都没有要传输的数据
      - 第一次挥手：客户端向服务器端请求关闭连接
      - 第二次挥手：服务端收到客户端的请求，并且告知客户端等我处理完数据
      - 第三次挥手：服务端处理完毕数据，告知客户端数据处理完毕
      - 第四次挥手：客户端得知服务端数据处理完毕，双方数据都处理完毕，可断开连接
3. CTIME-WAIT为什么是2MSL？

4. TCP和UDP的区别？
   UDP：发送时机易把控 无需建立连接 无连接状态 首部开销小
   TCP：面向连接 可靠传输
5. TCP是如何保证可靠性的，UDP为什么不可靠？

6. TCP报文包含哪些信息？

7. UDP包含哪些信息？
   源端口：16位
   目的端口：16位
   长度：16位
   校验和：16位
8. 三次握手和四次挥手过程中，网络断开会发生什么？